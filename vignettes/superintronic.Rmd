---
title: "Exploring intron signal with superintronic"
author: "Stuart Lee, Charity Law"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
                      fig.align = "center",
                      comment = "#>", 
                      message = FALSE,
                      warning = FALSE
                      )
```

## Preparing GFF/GTF files

```{r gff}
gff <- here::here("data-raw", "gencode.v27.annotation.gtf.gz")
ref <- BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38 %>% 
  get_genome_info() %>% 
  GenomeInfoDb::keepStandardChromosomes("Homo sapiens", "coarse")

gr_gff <- read_gff(gff, genome_info = ref )
anno <- prepare_annotation(gr_gff)
anno 
```

Once the annotation has been supplied you can explore various aspects,
```{r anno-summary}
anno %>% 
  group_by(n_olaps) %>% 
  summarise(n = n())
```

and given a set of rules, filter the annotation (by default we include
protein coding, genes with more than one exon, genes that do not overlap
any other genes)

```{r}
anno_sub <- anno %>% 
  filter_rules()

anno_sub
```


## Preparing BAM files

Generate a design data.frame containing filenames, and other variables.

```{r prepare-design}
tbl <- read.table(
  here::here("data-raw", "targets.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
  ) %>% 
  transform(File = S4Vectors::Rle(sub("\\.", "-", File))) %>%
  S4Vectors::DataFrame()

design <- tbl %>% 
  BiocGenerics::subset(Replicate %in% c("R1", "R2", "R3") & Mixture == 0) %>%  
  S4Vectors::transform(Sample = paste0(Replicate, "_", "HCC287"),
            CellLine = "HCC287")
design
```


Now we can take our BAM files and compute coverage. This
produces a large GRanges object, with two metadata columns,
`source` which is the BAM file  that coverage was computed for, and `score`
which is the coverage score. By default, this function computes
the coverage scores in parallel using BiocParallel.

An optional GRanges object may be passed to this function that will 
restrict the coverage computation to those regions; and set the annotation
in the resulting GRanges object. 

```{r compute-coverage}
cvg <- gather_coverage(here::here("data-raw", design$File),
                       genome_info = ref)
```

## Coverage over intronic/exonic regions

Now all the ingredients are in place to merge the coverage scores
to our prepared annotation with `merge_coverage()`. This again
returns a GRanges object, restricted to the intersection of the 
coverage ranges with intron/exon ranges. Additional columns are added
corresponding to the properties of the intron/exon.

```{r}
cvg_over_features <- merge_coverage(cvg, anno_sub)

cvg_over_features
```


Now we can begin summarising, here we spread the coverage table into wide
form by aggregating exon/intron coverage over each gene over all samples.
We can also add a thresholding argument to compute the number of bases 
above some score threshold and the proportion of bases above that threshold
that cover the total length of an exon/intron within a gene.

```{r}

exin_by_gene <- spread_coverage(
  cvg_over_features,
  threshold = 10L
)



view_exin(exin_by_gene,
          x = intron.average_coverage,
          y = intron.n_bases_above_threshold)

```


Now let's look at coverage plots for genes on the RHS of the scatter:

```{r}
high_intronic <- exin_by_gene %>% 
  subset(intron.average_coverage > 50) %>% 
  .$gene_id %>% 
  S4Vectors::runValue()



for (gene in high_intronic) {
  p <- anno_sub %>% 
    filter(gene_id == !!gene) %>% 
    view_coverage_within_gene(cvg_over_features, .)
  print(p)
}

```
