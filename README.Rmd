---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)

```
# superintronic

[![lifecycle](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![Build Status](https://travis-ci.org/sa-lee/superintronic.svg?branch=master)](https://travis-ci.org/sa-lee/superintronic)
[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/sa-lee/superintronic?branch=master&svg=true)](https://ci.appveyor.com/project/sa-lee/superintronic)
[![Codecov test coverage](https://codecov.io/gh/sa-lee/superintronic/branch/master/graph/badge.svg)](https://codecov.io/gh/sa-lee/superintronic?branch=master)


Exploring coverage signal in high-throughput 
(RNA) sequencing data via coverage estimation.

_superintronic_ centers around exploring coverage over exonic and intronic
regions via computing simple summary statistics and visualisations. 
The aim is to provide an extremely modular worklfow via an interface built on top of the 
[_plyranges_](https://sa-lee.github.io/plyranges/index.html) package. 
This means that you can modify any of the steps provided 
with the _plyranges_ grammar or just use our defaults.

The basic workflow consists of three steps  

1. Setting up annotations
2. Computing coverage
3. Visualising coverage results

## Setting up annotation GRanges

We assume you are starting from a GTF/GFF file for your given organism. 
The reading of the GFF file is done external to this package, 
and can be done via `rtracklayer::import` or `plyranges::read_gff`.
The resulting GRanges is passed to `collect_parts()`, then you can use
`plyranges::filter()` to select the criteria for genes you're interested in.

Alternatively, since `collect_parts()` is a generic we can also start
from any of the following objects:

* character vector containing a path to GFF file
* GFF/GTFFile class from `rtracklayer`
* TxDb and related Bioconductor

`collect_parts()` computes a `GRanges` with number of rows equal to genes,
it only considers intronic/exonic parts linked to a single gene only.

The result is a GRanges object with number of rows equal to genes,
and columns containing the intronic and exonic features (as list columns)
and the number of times a gene overlaps anyother feature (as well as
any associated information from the gtf file). 
```{r eval = TRUE}
library(superintronic)
library(magrittr)
library(plyranges)

features <- system.file("extdata", 
                        "Homo_sapiens.GRCh37.75_subset.gtf", 
                        package = "airway") %>% 
  collect_parts() %>% 
  filter(source == "protein_coding", n_olaps == 1)

features
```



## Computing coverage over BAM(s)

### Making coverage scores into a tidy GRanges

Here we compute a long form GRanges containing coverage scores in parallel over
a set of BAM files. We have structured it so you specify a data frame,
(like you would get from targets in `limma`), that contains a column
identified by `source`, that specifies the BAM file names. Other options
include specifying a GRanges that represents the genome build, an optional
target GRanges for restricting coverage (requiring the BAM to be indexed),
an argument for dropping entire regions that have zero coverage, and an
argumet for  parallel computations.

```{r, eval = FALSE}
# signature (dispatch on spec and source)
compute_coverage_long(spec,
                      source,
                      .target = NULL,
                      .genome_info = NULL,
                      .drop_empty = TRUE
                      .parallel = BiocParallel::bpparam()
                      )
```

This function automatically propagates, the metadata associated
with a design onto the resulting GRanges, however a user may also just
provide a vector of BAM files and then add any relevant design variables later
with `join_design()`.

As an example, let's use BAM files from the 
[`airway`](https://bioconductor.org/packages/release/data/experiment/html/airway.html)
data package.  

```{r, eval = TRUE}
design <- read.csv(system.file("extdata", 
                               "sample_table.csv", 
                               package = "airway")) %>% 
  dplyr::select(sample_id = X, cell, dex, albut) %>% 
  dplyr::mutate(bam = dir(system.file("extdata", package = "airway"), 
                          pattern = "*.bam",
                          full.names = TRUE)
  )

cvg <- compute_coverage_long(design, source = "bam")
cvg
```


Once the coverage is in long form, we can then merge overlapping genomic
features over the experimental design via an intersect overlap join and nesting
over the union ranges of an index  index (usually gene_id).

```{r, eval = TRUE}
cvg_over_features <- nest_by_overlaps(cvg,
                                      features, 
                                      .key = dplyr::vars(sample_id),
                                      .index = dplyr::vars(gene_id)
)

cvg_over_features
```


### Computing coverage wide form 

Returns a `RaggedExperiment` object (useful for doing things like PCA, CCA
more of a bioconductor approach etc.)

```{r, eval = FALSE}
compute_coverage_wide(design,
                      source,
                      .target = GenomicRanges::GRanges(),
                      .genome_info,
                      .parallel = BiocParallel::bpparam()
                      )
```



## Rangewise diagnostics 

We can then compute a bunch of `rangostics` (name TBD),
over a given (key and index) accross a column representing the coverage score.

* mean
* min, median, max
* quantile
* variance
* variance_shift
* bases_above_score
* near_feature_*covnostic*

Includes functions for purrr like mapping for sliding/tiling/stretching
over genomic windows.

This is conceptually similar to `dplyr::summarise_at` 
```{r, eval=FALSE}
rango(cvg_over_features, y = score, wt = width, .funs, ...)
```

## Visualising coverage scores

Options for visualising coverage over a given range 
```{r, eval = TRUE}
cvg_over_features <- join_parts(cvg, features) 

cvg_over_features %>% 
  view_coverage(., filter(features, gene_id == "ENSG00000116649"))

cvg_over_features %>% 
  view_coverage(., filter(features, gene_id == "ENSG00000116649"),
                facets = dplyr::vars(dex))
```

This returns a regular old ggplot object, so segments can be overlaid with
by adding to the plot object.


