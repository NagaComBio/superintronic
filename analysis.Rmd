---
title: "Coverage based analysis of Human Cell Lines"
author: "Stuart Lee"
date: "`r Sys.date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
                      fig.path = here::here("figures"), # processed figures go here
                      fig.align = "center",
                      comment = "#>", 
                      cache = here::here("data"), # store processed tables in data/
                      message = FALSE,
                      warning = FALSE
                      )
# Bioc Packages
library(GenomicFeatures)
library(plyranges)
library(Rsamtools)

# some viz ideas
library(ggplot2)
library(vegawidget)

# -- functions
flattenMD <- function(x, type = "exon") {
  type <- match.arg(type, choices =c("exon", "intron"))
  n_features_in_genes <- lengths(x)
  DataFrame(
    gene_id = Rle(names(x), lengths = n_features_in_genes),
    feature_type = Rle(factor(type, levels = c("exon", "intron")), 
                     lengths = sum(n_features_in_genes)),
    feature_rank = unlist(lapply(n_features_in_genes, seq_len), use.names = FALSE),
    feature_length = unlist(width(x), use.names = FALSE),
    feature_strand = unlist(strand(x), use.names = FALSE)
  )
}

compute_clean_coverage <- function(x) {
  cvg <- compute_coverage(x) %>%
    keepStandardChromosomes("Homo sapiens", pruning.mode = "coarse") %>% 
    set_genome_info(genome = "hg20")
  cvg
}

cvg_over_gene_plot <- function(cvg_features, gene_of_interest, txdb) {
  gene_id <- gene_of_interest$gene_id
  
  t1 <- cvg_features %>% 
    filter(gene_id == !!gene_id) %>% 
    ggbio::autoplot(., 
                    aes(
                      y = log2(score+1), 
                      group = Replicate, 
                      colour = feature_type
                    ), 
                    geom = "line") + 
    facet_grid(Kit ~ .) +
    scale_color_brewer(palette = "Dark2") +
    theme(axis.text.x = element_text(angle = 60, vjust = 0.5)) +
    labs(title = mcols(gene_of_interest)[["gene_name"]])
  #t2 <- ggbio::autoplot(txdb, which = gene_of_interest)
  #ggbio::tracks(t1, t2)
  t1
}

```


## Dataset: RNA-seq from mixology experiment

```{r exp-design}
tbl <- read.table(
  here::here("data-raw", "targets.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
  ) %>% 
  transform(File = sub("\\.", "-", File)) %>%
  as("DataFrame")

tbl
```

We take the six replicates for the unmixed HCC827 cell line and 
collect the file paths as a BamFileList. We also reduce the reference
annotations to main contigs of the genome build.

```{r unmixed-bams}



bams <- lapply(
  unmixed$File, 
  function(.) BamFile(here::here("data-raw", .))
  ) %>% 
  BamFileList()

# get annotation over main chromosomes
main_chr <- bams %>% 
  get_genome_info() %>% 
  keepStandardChromosomes("Homo sapiens", pruning.mode = "coarse") %>%
  set_genome_info(
    genome = "hg20",
    is_circular = as.vector(seqnames(.) == "chrM")
  )


```

## Computing coverage

Once we have the paths to our `BamFiles` we can compute coverage
in parallel using `BiocParallel` with `plyranges`. We will only keep
coverage scores over the main chromosomes of the reference.

```{r bam-coverage, cache = TRUE}

# process coverage in parallel
cvg <- BiocParallel::bplapply(
  bams, 
  FUN = compute_clean_coverage,
  BPPARAM = BiocParallel::MulticoreParam(workers = 6)
) %>% 
  GRangesList()

# add some metadata to coverage scores
md_cvg <- unmixed %>% 
  subset(select = c(Sample, Replicate, Kit)) %>% 
  transform(
    Sample = as(Sample, "Rle"),
    Replicate = as(Replicate, "Rle"),
    Kit = as(Kit, "Rle")
  )
# go from list to long form
n_grps <- lengths(cvg)
cvg <- unlist(cvg, use.names = FALSE)
mcols(cvg) <- cbind(
  mcols(cvg),
  md_cvg[rep.int(seq_len(nrow(unmixed)), n_grps), ]
  )

```

## Processing Annotation File

We construct an annotation database from the gencode annotation gtf provided,
and again restrict our features of interest to the standard chromosomes.

```{r make-features-db, cache =TRUE, dependson=main_chr}
txdb <- makeTxDbFromGFF(
  here::here("data-raw", "gencode.v27.annotation.gtf.gz"),
  chrominfo = seqinfo(main_chr)
)
```

Following, the creation of the annotation database, we can extract genes,
exons (by gene), and introns (by gene). We also compute the number of times
each gene overlaps another gene. 

```{r features}
# get genes, and create list columns for introns and exons 
features <- txdb %>%
  genes() %>% 
  mutate(
    n_self_overlaps = count_overlaps(., .),
    features_exons = txdb %>% 
      exonsBy("gene") %>% 
      reduce(),
    features_introns = . %setdiff% features_exons
  )

# how many self overlaps
features %>% 
  group_by(n_self_overlaps) %>% 
  summarise(n = n())
```

For the moment we will keep genes that have at least two exons

```{r one-gene}
# no overlaps, no 1 exon only lists
one_hits <- features %>% 
  filter(lengths(features_exons) > 1)

```

Now we flatten the exons and introns list columns them back to long form GRanges.
We also carry over metadata for each feature, such as total width, strand etc. 
as well. We then combine the features together into a single GRanges object.

```{r features-long-form, cache=TRUE}
# restore back to flat GRanges 
# remove only exonic features
md_exons <- flattenMD(one_hits$features_exons)
features_exons <- unlist(one_hits$features_exons, use.names = FALSE) 
mcols(features_exons) <- md_exons

md_introns <- flattenMD(one_hits$features_introns, 
                        type = "intron")
features_introns <- unlist(one_hits$features_introns, use.names = FALSE)
mcols(features_introns) <- md_introns

features_combined <- bind_ranges(features_exons, features_introns) %>% 
  sort()
features_combined
```


## Coverage summaries over features of interest

We use an overlap join, to compute the where the coverage vectors intersect
our exonic and intronic ranges. 

```{r olap-join-intersect, cache = TRUE}
cvg_features <- cvg %>% 
  join_overlap_intersect(features_combined)
```

We can now start computing summaries and visualisations 
over the samples of interest. 

```{r cvg-histogram, include = FALSE, eval = FALSE}
cvg_hist <- cvg_features %>% 
  group_by(Replicate, Kit, feature_type, score) %>% 
  summarise(n_bases = sum(width)) 

ggplot(as.data.frame(cvg_hist) %>% 
         filter(score < 300),
       aes(x = score, y = n_bases , color = feature_type)) +
  geom_line() +
  scale_y_log10() +
  facet_grid(Kit ~ Replicate)
```

We report coverage summary values per gene of:
	Trimmed mean (remove top and bottom 10%) coverage of exonic regions 
	Trimmed mean coverage of intronic regions by gene

The trimmed mean is estimated over all samples within gene and the 
scores are transformed using the log2 function with an offset of 1. 
From this weproduce a scatter plot over all genes of the trimmed coverage 
scores for exons against introns. Of interest are the following scenarios:

1. large exon and intron score -> intron retention?
2. large exon score and low intron score -> pre mRNA? unnanotated exon?


```{r tm-est}
tm_cvg <- cvg_features %>% 
  group_by(feature_type, gene_id) %>% 
  summarise(tm_score = mean(log2(score + 1), trim = 0.1))

tm_cvg_wide <- tm_cvg %>% 
  as.data.frame() %>% 
  tidyr::spread(feature_type, tm_score) 

tm_cvg_wide %>% 
  ggplot(aes(intron, exon)) + 
  geom_point(alpha = 0.1)
```


This plot provides a useful starting point for exploring the data in more detail
in essence we are interested in looking the coverage profiles for genes in
the right hand side and upper quadrant of the plot. That is, we want
the scatter plot to be linked to genome tracks.

But first let's explore some genes of interest - we need to grab the names
directly from our GTF now, as a `data.frame` and use that as a way of filtering
results.

```{r cvg_charts}
anno_df <- here::here("data-raw/gencode.v27.annotation.gtf.gz") %>% 
  read_gff() %>%
  filter(type == "gene") %>%
  select(gene_id, gene_type, gene_name)

genes_of_interest <- c("AC104534.1", "HNRNPL", "CPNE1", 
                       "VCL", "STAG3L5P-PVRIG2P-PILRB", "CD44")

sub_genes <- anno_df %>% 
  filter(gene_name %in% genes_of_interest)

for (i in seq_along(sub_genes)) {
  pl <- cvg_over_gene_plot(cvg_features, sub_genes[i])
  ggsave(filename = here::here("figures", paste0(sub_genes$gene_name[i], ".png")),
         pl@ggplot,
         dpi = 320)
}



sdata <- tm_cvg_wide %>% 
  filter(!is.na(exon)) %>% 
  dplyr::left_join(anno_df)

scatter <- list(
  data = list(values = sdata),
  selection = list(
    "get_gene" = list(type = "single")
  ),
  mark = "circle",
  encoding = list(
    x = list(field = "intron", type = "quantitative"),
    y = list(field = "exon", type = "quantitative"),
    color = list(
      condition = list(
        selection = "get_gene",
        value = "black"
      ),
      value = "grey"
    ),
    opacity = list(value = 0.2),
    tooltip = list(
      list(field = "seqnames", type = "ordinal"),
      list(field = "gene_id", type = "nominal"),
      list(field = "gene_name", type = "nominal"),
      list(field = "gene_type", type = "nominal")
      )
  )
)
```

Then we can add in the coverage scores:


```{r}
# add in features
all_cvg <- cvg_features %>% 
  mutate(score = log2(score + 1)) %>% 
  select(seqnames, start, end, score, gene_id, feature_type, Replicate, Kit, 
         .drop_ranges = TRUE) %>% 
  tibble::as_tibble()

cvg_line <- list(
  data = list(name = "scores"),
  transform = list(filter = list()),
  mark = "line",
  encoding = list(
    x = list(field = "start", type = "quantitative", scale = list(zero = FALSE)),
    x2 = list(field = "end", type = "quantitative"),
    y = list(field = "score", type = "quantitative"),
    color = list(field = "Replicate", type = "ordinal"),
    row = list(field = "Kit", type = "nominal")
  )
)

```



ideogram <- list(
  data = list(values = example_anno),
  mark = "rect",
  encoding = list(
    x = list(field = "start", type = "quantitative", 
             scale = list(zero = FALSE)),
    x2 = list(field = "end", type = "quantitative"),
    y = list(field = "gene_id", type = "ordinal", axis = list(labels = FALSE, title = NULL))
  )  
)

db <- list(`$schema` = vega_schema(), 
           vconcat = list(cvg_line, ideogram))

```

	